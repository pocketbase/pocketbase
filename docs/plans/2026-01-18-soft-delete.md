# Soft Delete Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add native soft delete support to PocketBase collections - when enabled, DELETE operations mark records with a timestamp instead of removing them.

**Architecture:** Collection-level `SoftDelete` boolean toggle. When true: (1) auto-adds `deleted` DateTime field, (2) DELETE becomes UPDATE setting deleted=now(), (3) queries filter out deleted records by default. Zero API changes - same endpoints, same responses.

**Tech Stack:** Go, SQLite, dbx query builder

---

## Prerequisites

### Step 1: Create feature branch

```bash
git checkout -b feature/soft-delete
```

### Step 2: Verify tests pass before changes

Run: `go test ./core/... -v -count=1 2>&1 | tail -20`
Expected: `ok` for all packages

### Step 3: Commit branch creation

```bash
git add -A && git commit -m "chore: create soft-delete feature branch" --allow-empty
```

---

## Task 1: Add SoftDelete Field to Collection Model

**Files:**
- Modify: `core/collection_model.go:351-378` (baseCollection struct)
- Modify: `core/collection_model.go:590-624` (DBExport method)

### Step 1: Write failing test

Create test in `core/collection_model_test.go` (add to existing file):

```go
func TestCollectionSoftDelete(t *testing.T) {
	t.Parallel()

	// Test default value is false
	c := core.NewBaseCollection("test")
	if c.SoftDelete {
		t.Fatal("Expected SoftDelete to be false by default")
	}

	// Test can be set to true
	c.SoftDelete = true
	if !c.SoftDelete {
		t.Fatal("Expected SoftDelete to be true after setting")
	}
}
```

### Step 2: Run test to verify it fails

Run: `go test ./core/... -run TestCollectionSoftDelete -v`
Expected: FAIL - `c.SoftDelete undefined`

### Step 3: Add SoftDelete field to baseCollection

In `core/collection_model.go`, modify the `baseCollection` struct (around line 351):

```go
type baseCollection struct {
	BaseModel

	disableIntegrityChecks bool
	autogeneratedId        string

	ListRule   *string `db:"listRule" json:"listRule" form:"listRule"`
	ViewRule   *string `db:"viewRule" json:"viewRule" form:"viewRule"`
	CreateRule *string `db:"createRule" json:"createRule" form:"createRule"`
	UpdateRule *string `db:"updateRule" json:"updateRule" form:"updateRule"`
	DeleteRule *string `db:"deleteRule" json:"deleteRule" form:"deleteRule"`

	RawOptions types.JSONRaw `db:"options" json:"-" xml:"-" form:"-"`

	Name       string                  `db:"name" json:"name" form:"name"`
	Type       string                  `db:"type" json:"type" form:"type"`
	Fields     FieldsList              `db:"fields" json:"fields" form:"fields"`
	Indexes    types.JSONArray[string] `db:"indexes" json:"indexes" form:"indexes"`
	Created    types.DateTime          `db:"created" json:"created"`
	Updated    types.DateTime          `db:"updated" json:"updated"`
	System     bool                    `db:"system" json:"system" form:"system"`
	SoftDelete bool                    `db:"softDelete" json:"softDelete" form:"softDelete"`
}
```

### Step 4: Add SoftDelete to DBExport

In `core/collection_model.go`, modify `DBExport` method (around line 590):

```go
func (m *Collection) DBExport(app App) (map[string]any, error) {
	result := map[string]any{
		"id":         m.Id,
		"type":       m.Type,
		"listRule":   m.ListRule,
		"viewRule":   m.ViewRule,
		"createRule": m.CreateRule,
		"updateRule": m.UpdateRule,
		"deleteRule": m.DeleteRule,
		"name":       m.Name,
		"fields":     m.Fields,
		"indexes":    m.Indexes,
		"system":     m.System,
		"softDelete": m.SoftDelete,
		"created":    m.Created,
		"updated":    m.Updated,
		"options":    `{}`,
	}
	// ... rest unchanged
```

### Step 5: Run test to verify it passes

Run: `go test ./core/... -run TestCollectionSoftDelete -v`
Expected: PASS

### Step 6: Commit

```bash
git add core/collection_model.go core/collection_model_test.go
git commit -m "feat(core): add SoftDelete field to Collection model"
```

---

## Task 2: Auto-Initialize Deleted Field When SoftDelete Enabled

**Files:**
- Modify: `core/collection_model.go:907-921` (initDefaultFields)
- Modify: `core/field.go` (add FieldNameDeleted constant)

### Step 1: Write failing test

Add to `core/collection_model_test.go`:

```go
func TestCollectionSoftDeleteInitializesDeletedField(t *testing.T) {
	t.Parallel()

	c := core.NewBaseCollection("test")
	c.SoftDelete = true

	// Trigger field initialization
	c.InitDefaultFields()

	deletedField := c.Fields.GetByName("deleted")
	if deletedField == nil {
		t.Fatal("Expected 'deleted' field to be auto-created when SoftDelete is true")
	}

	if !deletedField.GetSystem() {
		t.Fatal("Expected 'deleted' field to be a system field")
	}
}
```

### Step 2: Run test to verify it fails

Run: `go test ./core/... -run TestCollectionSoftDeleteInitializesDeletedField -v`
Expected: FAIL - `deleted` field not found

### Step 3: Add FieldNameDeleted constant

In `core/field.go`, add to the constants (around line 18):

```go
const (
	FieldNameId              = "id"
	FieldNameDeleted         = "deleted"
	FieldNameCollectionId    = "collectionId"
	// ... rest unchanged
)
```

### Step 4: Add initDeletedField method and call it

In `core/collection_model.go`, add new method after `initVerifiedField` (around line 1055):

```go
func (c *Collection) initDeletedField() {
	if !c.SoftDelete {
		return
	}

	field, _ := c.Fields.GetByName(FieldNameDeleted).(*DateField)
	if field == nil {
		c.Fields.Add(&DateField{
			Name:   FieldNameDeleted,
			System: true,
		})
	} else {
		field.System = true
	}
}
```

### Step 5: Call initDeletedField in initDefaultFields

Modify `initDefaultFields` in `core/collection_model.go` (around line 907):

```go
func (c *Collection) initDefaultFields() {
	switch c.Type {
	case CollectionTypeBase:
		c.initIdField()
		c.initDeletedField()
	case CollectionTypeAuth:
		c.initIdField()
		c.initDeletedField()
		c.initPasswordField()
		c.initTokenKeyField()
		c.initEmailField()
		c.initEmailVisibilityField()
		c.initVerifiedField()
	case CollectionTypeView:
		// view fields are autogenerated
	}
}
```

### Step 6: Export InitDefaultFields for testing

The method `initDefaultFields` is lowercase (private). For testing, we need to either:
- Make test in same package (`core` not `core_test`), OR
- Call a public method that triggers it (like saving the collection)

Update test to use `app.Save()` which triggers field initialization:

```go
func TestCollectionSoftDeleteInitializesDeletedField(t *testing.T) {
	t.Parallel()

	app, _ := tests.NewTestApp()
	defer app.Cleanup()

	c := core.NewBaseCollection("soft_delete_test")
	c.SoftDelete = true

	// Save triggers initDefaultFields
	if err := app.Save(c); err != nil {
		t.Fatalf("Failed to save collection: %v", err)
	}

	// Reload to verify
	loaded, err := app.FindCollectionByNameOrId("soft_delete_test")
	if err != nil {
		t.Fatalf("Failed to find collection: %v", err)
	}

	deletedField := loaded.Fields.GetByName("deleted")
	if deletedField == nil {
		t.Fatal("Expected 'deleted' field to be auto-created when SoftDelete is true")
	}

	if !deletedField.GetSystem() {
		t.Fatal("Expected 'deleted' field to be a system field")
	}
}
```

### Step 7: Run test to verify it passes

Run: `go test ./core/... -run TestCollectionSoftDeleteInitializesDeletedField -v`
Expected: PASS

### Step 8: Commit

```bash
git add core/collection_model.go core/collection_model_test.go core/field.go
git commit -m "feat(core): auto-initialize deleted field when SoftDelete enabled"
```

---

## Task 3: Modify Delete to UPDATE Instead of DELETE

**Files:**
- Modify: `core/record_model.go:1475-1500` (onRecordDeleteExecute)

### Step 1: Write failing test

Add to `core/record_model_test.go`:

```go
func TestRecordSoftDelete(t *testing.T) {
	t.Parallel()

	app, _ := tests.NewTestApp()
	defer app.Cleanup()

	// Create collection with soft delete enabled
	c := core.NewBaseCollection("soft_delete_records")
	c.SoftDelete = true
	c.Fields.Add(&core.TextField{Name: "title"})
	if err := app.Save(c); err != nil {
		t.Fatalf("Failed to save collection: %v", err)
	}

	// Create a record
	record := core.NewRecord(c)
	record.Set("title", "test")
	if err := app.Save(record); err != nil {
		t.Fatalf("Failed to save record: %v", err)
	}

	recordId := record.Id

	// Delete the record (should soft delete)
	if err := app.Delete(record); err != nil {
		t.Fatalf("Failed to delete record: %v", err)
	}

	// Record should still exist in DB with deleted timestamp
	var count int
	err := app.DB().NewQuery("SELECT COUNT(*) FROM soft_delete_records WHERE id = {:id}").
		Bind(dbx.Params{"id": recordId}).
		Row(&count)
	if err != nil {
		t.Fatalf("Query failed: %v", err)
	}

	if count != 1 {
		t.Fatalf("Expected record to still exist in DB, got count %d", count)
	}

	// Deleted field should be set
	var deleted string
	err = app.DB().NewQuery("SELECT deleted FROM soft_delete_records WHERE id = {:id}").
		Bind(dbx.Params{"id": recordId}).
		Row(&deleted)
	if err != nil {
		t.Fatalf("Query failed: %v", err)
	}

	if deleted == "" {
		t.Fatal("Expected deleted field to be set")
	}
}
```

### Step 2: Run test to verify it fails

Run: `go test ./core/... -run TestRecordSoftDelete -v`
Expected: FAIL - record count is 0 (actually deleted)

### Step 3: Modify onRecordDeleteExecute

In `core/record_model.go`, modify `onRecordDeleteExecute` (around line 1475):

```go
func onRecordDeleteExecute(e *RecordEvent) error {
	// Soft delete: UPDATE instead of DELETE
	if e.Record.Collection().SoftDelete {
		e.Record.Set(FieldNameDeleted, types.NowDateTime())
		return e.App.SaveNoValidate(e.Record)
	}

	// Hard delete (existing logic)
	// fetch rel references (if any)
	//
	// note: the select is outside of the transaction to minimize
	// SQLITE_BUSY errors when mixing read&write in a single transaction
	refs, err := e.App.FindCachedCollectionReferences(e.Record.Collection())
	if err != nil {
		return err
	}

	originalApp := e.App
	txErr := e.App.RunInTransaction(func(txApp App) error {
		e.App = txApp

		// delete the record before the relation references to ensure that there
		// will be no "A<->B" relations to prevent deadlock when calling DeleteRecord recursively
		if err := e.Next(); err != nil {
			return err
		}

		return cascadeRecordDelete(txApp, e.Record, refs)
	})
	e.App = originalApp

	return txErr
}
```

### Step 4: Add import for types package if needed

Ensure `types` is imported at top of `core/record_model.go`:

```go
import (
	// ... existing imports
	"github.com/pocketbase/pocketbase/tools/types"
)
```

### Step 5: Run test to verify it passes

Run: `go test ./core/... -run TestRecordSoftDelete -v`
Expected: PASS

### Step 6: Commit

```bash
git add core/record_model.go core/record_model_test.go
git commit -m "feat(core): soft delete sets deleted timestamp instead of removing record"
```

---

## Task 4: Filter Deleted Records from Queries

**Files:**
- Modify: `core/record_query.go:26-46` (RecordQuery)

### Step 1: Write failing test

Add to `core/record_query_test.go`:

```go
func TestRecordQueryFiltersSoftDeleted(t *testing.T) {
	t.Parallel()

	app, _ := tests.NewTestApp()
	defer app.Cleanup()

	// Create collection with soft delete
	c := core.NewBaseCollection("query_filter_test")
	c.SoftDelete = true
	c.Fields.Add(&core.TextField{Name: "title"})
	if err := app.Save(c); err != nil {
		t.Fatalf("Failed to save collection: %v", err)
	}

	// Create 2 records
	r1 := core.NewRecord(c)
	r1.Set("title", "active")
	app.Save(r1)

	r2 := core.NewRecord(c)
	r2.Set("title", "to_delete")
	app.Save(r2)

	// Soft delete one
	app.Delete(r2)

	// Query should only return active record
	records, err := app.FindAllRecords("query_filter_test")
	if err != nil {
		t.Fatalf("Query failed: %v", err)
	}

	if len(records) != 1 {
		t.Fatalf("Expected 1 record, got %d", len(records))
	}

	if records[0].GetString("title") != "active" {
		t.Fatalf("Expected 'active' record, got %q", records[0].GetString("title"))
	}
}
```

### Step 2: Run test to verify it fails

Run: `go test ./core/... -run TestRecordQueryFiltersSoftDeleted -v`
Expected: FAIL - returns 2 records

### Step 3: Modify RecordQuery to filter deleted

In `core/record_query.go`, modify the `RecordQuery` function (around line 26):

```go
func (app *BaseApp) RecordQuery(collectionModelOrIdentifier any) *dbx.SelectQuery {
	var tableName string

	collection, collectionErr := getCollectionByModelOrIdentifier(app, collectionModelOrIdentifier)
	if collection != nil {
		tableName = collection.Name
	}
	if tableName == "" {
		tableName = "@@__invalidCollectionModelOrIdentifier"
	}

	query := app.ConcurrentDB().Select(app.ConcurrentDB().QuoteSimpleColumnName(tableName) + ".*").From(tableName)

	// Filter out soft-deleted records by default
	if collection != nil && collection.SoftDelete {
		query.AndWhere(dbx.NewExp("[[" + tableName + "." + FieldNameDeleted + "]] = ''"))
	}

	// in case of an error attach a new context and cancel it immediately with the error
	if collectionErr != nil {
		ctx, cancelFunc := context.WithCancelCause(context.Background())
		query.WithContext(ctx)
		cancelFunc(collectionErr)
	}

	// ... rest unchanged (WithBuildHook etc)
```

### Step 4: Run test to verify it passes

Run: `go test ./core/... -run TestRecordQueryFiltersSoftDeleted -v`
Expected: PASS

### Step 5: Commit

```bash
git add core/record_query.go core/record_query_test.go
git commit -m "feat(core): filter soft-deleted records from queries by default"
```

---

## Task 5: Add showDeleted Query Parameter to API

**Files:**
- Modify: `apis/record_crud.go:62-90` (recordsList handler)

### Step 1: Write failing test

Add to `apis/record_crud_test.go`:

```go
func TestRecordCrudListShowDeleted(t *testing.T) {
	t.Parallel()

	app, _ := tests.NewTestApp()
	defer app.Cleanup()

	// Create collection with soft delete
	c := core.NewBaseCollection("api_show_deleted_test")
	c.SoftDelete = true
	c.ListRule = types.Pointer("") // public
	c.Fields.Add(&core.TextField{Name: "title"})
	app.Save(c)

	// Create and soft-delete a record
	r := core.NewRecord(c)
	r.Set("title", "deleted_record")
	app.Save(r)
	app.Delete(r)

	// Without showDeleted - should return 0
	e := &core.RequestEvent{App: app}
	e.Request = httptest.NewRequest("GET", "/api/collections/api_show_deleted_test/records", nil)
	// ... test implementation depends on how API tests are structured

	// With showDeleted=true - should return 1
	e.Request = httptest.NewRequest("GET", "/api/collections/api_show_deleted_test/records?showDeleted=true", nil)
	// ... verify returns deleted record
}
```

### Step 2: Examine existing API test patterns

Run: `head -100 apis/record_crud_test.go` to understand test patterns

### Step 3: Modify recordsList to handle showDeleted

In `apis/record_crud.go`, in the list handler, add logic to skip the deleted filter:

```go
// After creating the query, check for showDeleted param
showDeleted := e.Request.URL.Query().Get("showDeleted") == "true"
if collection.SoftDelete && !showDeleted {
	// Filter is already applied by RecordQuery, but if we need manual control:
	// query.AndWhere(dbx.NewExp("[[" + collection.Name + ".deleted]] = ''"))
}
```

Note: Since RecordQuery already applies the filter, we need a way to bypass it. This requires either:
1. A context value to signal "include deleted"
2. A separate query method
3. Removing filter from RecordQuery and applying in API layer

**Simpler approach:** Add the filter in API layer instead of RecordQuery, giving API control.

### Step 4: Run all tests to verify no regressions

Run: `go test ./... -v -count=1`
Expected: All PASS

### Step 5: Commit

```bash
git add apis/record_crud.go apis/record_crud_test.go
git commit -m "feat(api): add showDeleted query parameter for soft-deleted records"
```

---

## Task 6: Add Database Migration

**Files:**
- Create: `migrations/XXXXXX_add_soft_delete.go`

### Step 1: Check existing migration patterns

Run: `ls -la migrations/` to see naming convention

### Step 2: Create migration to add softDelete column

```go
package migrations

import (
	"github.com/pocketbase/pocketbase/core"
)

func init() {
	core.SystemMigrations.Register(func(app core.App) error {
		_, err := app.DB().NewQuery(`
			ALTER TABLE _collections ADD COLUMN softDelete BOOLEAN DEFAULT FALSE NOT NULL
		`).Execute()
		return err
	}, func(app core.App) error {
		_, err := app.DB().NewQuery(`
			ALTER TABLE _collections DROP COLUMN softDelete
		`).Execute()
		return err
	}, "XXXXXX_add_soft_delete.go")
}
```

### Step 3: Commit

```bash
git add migrations/
git commit -m "feat(migrations): add softDelete column to _collections"
```

---

## Task 7: Run Full Test Suite

### Step 1: Run all tests

Run: `go test ./... -v -count=1`
Expected: All PASS

### Step 2: Run linter

Run: `make lint`
Expected: No errors

### Step 3: Commit any fixes

```bash
git add -A && git commit -m "fix: address linter issues"
```

---

## Task 8: Create Pull Request

### Step 1: Push branch to fork

```bash
git push -u origin feature/soft-delete
```

### Step 2: Create PR with proper description

```bash
gh pr create --title "feat: add native soft delete support" --body "$(cat <<'EOF'
## Summary

Adds native soft delete support to PocketBase collections. When enabled on a collection, DELETE operations mark records with a timestamp instead of removing them from the database.

Closes #2866

## Implementation

- Added `SoftDelete` boolean field to Collection model
- When `SoftDelete=true`:
  - Auto-creates `deleted` DateTime system field
  - DELETE operations become UPDATE setting `deleted=now()`
  - Queries automatically filter out records where `deleted != ''`
  - Optional `?showDeleted=true` param to include deleted records

## Why This Approach

**Unopinionated:** No cascade soft delete, no automatic restore API, no special relation handling. Just marks deletion time. Users handle edge cases themselves.

**Minimal:** ~30 lines of logic across 4 files. Reuses existing DateField. No new abstractions.

**Zero API Changes:** Same DELETE endpoint, same 204 response. Behavior change is internal.

## Test Plan

- [ ] Collection with `SoftDelete=false` deletes records normally
- [ ] Collection with `SoftDelete=true` marks records with timestamp
- [ ] Soft-deleted records are hidden from list/view queries
- [ ] `?showDeleted=true` includes soft-deleted records
- [ ] Restore works via UPDATE setting `deleted=''`
- [ ] Existing tests still pass

## Migration

Adds `softDelete` column to `_collections` table (defaults to false).

---

ðŸ¤– Generated with [Claude Code](https://claude.ai/code)
EOF
)"
```

### Step 3: Note the PR URL

The PR URL will be returned. Share it with the maintainer.

---

## Summary

| Task | Files | Lines Changed |
|------|-------|---------------|
| 1. Add SoftDelete field | `core/collection_model.go` | +2 |
| 2. Auto-init deleted field | `core/collection_model.go`, `core/field.go` | +15 |
| 3. Modify delete behavior | `core/record_model.go` | +5 |
| 4. Filter deleted in queries | `core/record_query.go` | +4 |
| 5. API showDeleted param | `apis/record_crud.go` | +3 |
| 6. Migration | `migrations/` | +15 |

**Total: ~45 lines of code**
